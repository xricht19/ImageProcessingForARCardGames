#include "ImageDetectionAccessPoint.h"

namespace IDAP
{
	// private function area ------------------------------------------------------------------
	void ImageDetectionAccessPoint::loadSettingsFromXmlAndInit(const char* path)
	{
		// open and read xml file
		rapidxml::file<> xmlSettingsFile(path);
		rapidxml::xml_document<> doc;
		doc.parse<0>(xmlSettingsFile.data());

		rapidxml::xml_node<> *rootNode = doc.first_node();
		std::cout << " root Node: " << rootNode->name() << std::endl;

		// load these info
		rapidxml::xml_node<> *centralAreaNode = rootNode->first_node("CentralArea");
		rapidxml::xml_node<> *playersNode = rootNode->first_node("Players");
		rapidxml::xml_node<> *cardsPositionsNode = rootNode->first_node("CardsPosition");

		// save the size of all types of cards with it's id
		rapidxml::xml_node<> *gameSettingsNode = rootNode->first_node("ARBangGameSettings");
		for (rapidxml::xml_node<> *child = gameSettingsNode->first_node(); child; child = child->next_sibling()) {
			if (child == NULL) 
				break;
			Card newTypeOfCard = Card(child->first_attribute("id")->value(), child->first_node("width")->value(), child->first_node("height")->value());
			cardTypes.push_back(newTypeOfCard);
		}

#ifdef _DEBUG
		for each (auto card in cardTypes)
		{
			std::cout << "ID: " << card.getID() << "| H: " << card.getHeight() << "| W: " << card.getWidth() << std::endl;
		}
#endif
	}


	// public function area -------------------------------------------------------------------
	ImageDetectionAccessPoint::ImageDetectionAccessPoint()
	{
	}


	ImageDetectionAccessPoint::~ImageDetectionAccessPoint()
	{
	}

	void ImageDetectionAccessPoint::GetVideoResolution(uint16_t& errorCode, uint16_t& width, uint16_t& height)
	{
		if (!openedStream.isOpened()) {
			errorCode = ErrorCodes::VIDEO_STREAM_IS_NOT_OPENED;
			width = 0;
			height = 0;
		}
		else {
			height = (uint16_t)openedStream.get(cv::CAP_PROP_FRAME_HEIGHT);
			width = (uint16_t)openedStream.get(cv::CAP_PROP_FRAME_WIDTH);
		}


	}

	void ImageDetectionAccessPoint::PrepareNextFrame(uint16_t &errorCode)
	{
		if (!openedStream.isOpened()) {
			errorCode = ErrorCodes::VIDEO_STREAM_IS_NOT_OPENED;
		}
		else {
			// get next frame
			openedStream >> frame;
			if (frame.empty()) {
				errorCode = ErrorCodes::CANNOT_GET_IMAGE_FROM_CAMERA;
			}
		}

	}

	void ImageDetectionAccessPoint::GetCurrentFrameData(uint16_t &errorCode, uint16_t &rows, uint16_t &columns, uint16_t &channels, uchar* &dataBytes)
	{
		if (!openedStream.isOpened() && !usingROS) {
			errorCode = ErrorCodes::VIDEO_STREAM_IS_NOT_OPENED;
		}
		else if (frame.empty()) {
			errorCode = ErrorCodes::FRAME_WAS_NOT_READ;
		}
		else {
			rows = (uint16_t)frame.rows;
			columns = (uint16_t)frame.cols;
			channels = (uint16_t)frame.channels();
			dataBytes = frame.data;
		}
	}

	void ImageDetectionAccessPoint::IsPlayerActiveByID(uint16_t &errorCode, uint16_t &)
	{
	}

	void ImageDetectionAccessPoint::HasGameObjectChanged(uint16_t &errorCode, uint16_t &positionID, uint16_t &objectID)
	{
	}

	void ImageDetectionAccessPoint::GetNumberOfAllAvailableDevices(uint16_t &errorCode, uint16_t &numOfDevices)
	{
		numOfDevices = 0;
		// try open all video stream, until not available
		uint16_t deviceID = 0;
		cv::VideoCapture testIfOpenPoss;
		while (true) {
			testIfOpenPoss = cv::VideoCapture(deviceID);
			if (!testIfOpenPoss.isOpened()) {
				errorCode = ErrorCodes::CANNOT_OPEN_VIDEO_STREAM;
				break;
			}
			numOfDevices++;
			deviceID++;
		}
	}

	void ImageDetectionAccessPoint::InitImageDetectionAccessPoint(uint16_t& errorCode, uint16_t& cameraId, const char* settingsPath)
	{
		// TODO: load settings from xml generated by Unity
		std::cout << settingsPath << std::endl;
		this->loadSettingsFromXmlAndInit(settingsPath);

		/*this->usingROS = false;

		openedStream = cv::VideoCapture(cameraId);
		if (!openedStream.isOpened()) {
			errorCode = ErrorCodes::CANNOT_OPEN_VIDEO_STREAM;
			return;
		}	*/
	}

	void ImageDetectionAccessPoint::InitImageDetectionAccessPointROS(uint16_t &errorCode, uchar *ipAdress, uint16_t &port, const char* &settingsPath)
	{
#ifdef _WIN32
		this->usingROS = true;
#else
		errorCode = ErrorCodes::CONNECTION_TO_ROS_IS_AVAILABLE_ONLY_ON_WINDOWS;
#endif
	}


// -------- CARD --------------------------------------------
	Card::Card(char * _id, char * _width, char * _height)
	{
		// convert to int
		std::stringstream strValue;
		strValue << _id;
		strValue >> id;

		strValue.clear();
		strValue << _width;
		strValue >> width;
		
		strValue.clear();
		strValue << _height;
		strValue >> height;
	}
}